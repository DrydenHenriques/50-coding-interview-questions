# 50-coding-interview-questions
> Don't do another coding interview... Until you've mastered these 50 whiteboarding questions.
> <p align='center'>&mdash;Sam Gavis-Hughson, founder of Byte by Byte</p>

You can subscribe these problems from [here](https://www.byte-by-byte.com/50-questions/). Really appreciate it to [Sam](https://www.byte-by-byte.com/about/).

## Guide
Learn how to develop a systematic approach to each problem as follows:

### 1. Understand the problem
Understanding exactly what is being asked is critical to your success. Ask any clarifying questions necessary. Look at the input and figure out how that resulted in the given output. If you see any obvious problem areas or edge cases, add in your own example. Based on the input and output, what should be the signature of your function?

### 2. Find a brute force solution
The brute force solution makes you really understand the problem, and guarantees that you find a solution. Far too many people try to jump into an optimized solution and get lost. It's really hard to recover without simply starting over, and in an interview you definitely don't have time to start over.

### 3. Optimize the brute force solution
Time to shine yourself. But you shouldn't spend more than 5-10 minutes on this step before moving on to coding. Try brainstorming more efficient data structures, looking at duplicated or unnecessary work, or just looking for more efficient solutions unrelated to your brute force solution.

### 4. Code the solution
Since you've done all the legwork, coding should be the easy part. If not, it's worth dedicating time to practicing coding, particularly on paper or a whiteboard.

### 5. Test the solution
This final step is critical. Not only does it show your interviewer that you're careful and thorough, it gives yourself the confidence that your solution is correct. Go through the code line by line. Missing small typos or indexing errors could leave a bad taste in your interviewer's mouth even if you did well otherwise.

## Problems
### Array(1-14)
- [x] [Median of Arrays](array/01_Median-of-Arrays.py)
- [x] [0-1 Knapsack](array/02_0-1-Knapsack.py)
- [x] [Matrix Product](array/03_Matrix-Product.py)
- [x] [Find Duplicates](array/04_Find-Duplicates.py)
- [x] [Consecutive Array](array/05_Consecutive-Array.py)
- [x] [Zero Matrix](array/06_Zero-Matrix.py)
- [x] [*Square Submatrix](array/07_Square-Submatrix.py)
- [x] [Merge K Arrays](array/08_Merge-K-Arrays.py)
- [ ] Matrix Search
- [ ] Merge Arrays
- [ ] Zero Sum Subarray
- [ ] Permutations
- [ ] N Stacks
- [ ] Anagrams

### Graph(15-16)
- [ ] Build Order
- [ ] Shortest Path

### Recursion(17-26)
- [ ] Random Binary Tree
- [ ] Lowest Common Ancestor
- [ ] Sum
- [ ] Reverse Stack
- [ ] Tree to Doubly Linked List
- [ ] Longest Consecutive Branch
- [ ] Print Reversed Linked List
- [ ] Balanced Binary Tree
- [ ] Binary Search Tree Verification
- [ ] Smallest Change

### Stack(27-31)
- [ ] Inorder Traversal
- [ ] Sort Stacks
- [ ] Stack from Queues
- [ ] Palindromes
- [ ] Max Stacks

### Bit Manipulation(32-37)
- [ ] Two Missing Numbers
- [ ] Bit Int Modules
- [ ] Swap Variables
- [ ] Gray Code
- [ ] Rotate Bits
- [ ] Number of Ones in a Binary Number

### Linked List(38-44)
- [ ] Linked List Cycles
- [ ] Random Linked List
- [ ] Dedup Linked List
- [ ] Split a Linked List
- [ ] Nth to the Last Element
- [ ] Three Sum
- [ ] Tree Level Order

### String(45-51)
- [ ] Autocomplete
- [ ] String Deletion
- [ ] Longest Common Substring
- [ ] String Compression
- [ ] Fibonacci Number
- [ ] Priority Queue
- [ ] Kth Most Frequent String
